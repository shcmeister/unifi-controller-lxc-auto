#!/bin/bash

# Този скрипт се изпълнява на Proxmox хост.
# Той автоматизира създаването на LXC контейнер и пълната инсталация на UniFi Network Controller вътре в него.

# --- Конфигурация на LXC контейнера ---
CTID=$(pvesh get /cluster/nextid) # ID на контейнера (автоматично ще бъде следващото налично ID)
HOSTNAME="unifi-$CTID"        # Име на хоста на контейнера (ще включва ID за уникалност)
TEMPLATE="debian-12-standard_12.7-1_amd64.tar.zst" # Шаблон на ОС
MEMORY=2048                   # RAM в MB (2GB препоръчително за UniFi)
DISK_SIZE=10                  # Размер на диска в GB (10GB е добро начало)
CORES=2                       # Брой CPU ядра
MONGO_VERSION="7.0"           # Версия на MongoDB, съвместима с UniFi

# --- Лог функция ---
log_message() {
    echo -e "\033[1;34m--- $(date +'%Y-%m-%d %H:%M:%S') --- $1\033[0m"
}

# --- Проверка за root привилегии на хоста ---
if [[ $EUID -ne 0 ]]; then
    echo -e "\033[1;31mГрешка: Този скрипт трябва да се изпълнява като root потребител на Proxmox хоста!\033[0m"
    exit 1
fi

# --- Проверка за pct команда (указва, че е Proxmox хост) ---
if ! command -v pct >/dev/null 2>&1; then
    echo -e "\033[1;31mГрешка: Командата 'pct' не е намерена. Моля, изпълнете този скрипт на Proxmox хост.\033[0m"
    exit 1
fi

log_message "Стартиране на скрипта за автоматична инсталация на UniFi LXC."

# --- Проверка за съществуващ CTID ---
if pct status $CTID &>/dev/null; then
    echo -e "\033[1;31mГрешка: LXC контейнер с ID $CTID вече съществува. Моля, променете CTID в скрипта или изтрийте съществуващия контейнер.\033[0m"
    exit 1
fi

# --- Функция за намиране на storage с най-много свободно място ---
get_best_storage() {
    local pvesm_output
    pvesm_output=$(pvesm status 2>&1)
    local pvesm_status_code=$?

    if [ "$pvesm_status_code" -ne 0 ]; then
        log_message "Грешка при изпълнение на 'pvesm status': $pvesm_output"
        return 1
    fi

    echo "$pvesm_output" | awk '
        BEGIN {
            NAME_COL=-1; TYPE_COL=-1; AVAIL_COL=-1;
        }
        NR==1 {
            for (i=1; i<=NF; i++) {
                if ($i == "Storage") NAME_COL=i;
                if ($i == "Type") TYPE_COL=i;
                if ($i == "Avail") AVAIL_COL=i;
            }
            if (NAME_COL == -1 || TYPE_COL == -1 || AVAIL_COL == -1) {
                print "Error: Could not find columns in pvesm status output." > "/dev/stderr";
                exit 1;
            }
            next;
        }
        {
            storage_name=$NAME_COL
            storage_type=$TYPE_COL
            avail_size_str=$AVAIL_COL

            if (storage_name ~ /(iso|backup)/ || storage_type !~ /(dir|lvmthin|zfspool)/ || storage_name == "") {
                next;
            }
            
            avail_mb = 0;
            num_value = avail_size_str;
            unit_char = "";
            if (avail_size_str ~ /[KMGTPEkmgtpe]$/) {
                unit_char = substr(avail_size_str, length(avail_size_str));
                num_value = substr(avail_size_str, 1, length(avail_size_str)-1);
            }

            if (num_value ~ /^[0-9.]+$/) {
                if (unit_char == "K" || unit_char == "k") avail_mb = num_value / 1024;
                else if (unit_char == "M" || unit_char == "m") avail_mb = num_value;
                else if (unit_char == "G" || unit_char == "g") avail_mb = num_value * 1024;
                else if (unit_char == "T" || unit_char == "t") avail_mb = num_value * 1024 * 1024;
                else if (unit_char == "P" || unit_char == "p") avail_mb = num_value * 1024 * 1024 * 1024;
                else if (unit_char == "E" || unit_char == "e") avail_mb = num_value * 1024 * 1024 * 1024 * 1024;
                else if (unit_char == "") avail_mb = num_value;
            }

            if (avail_mb > 0) {
                print storage_name, avail_mb
            }
        }
    ' | sort -nrk2 | head -n1 | awk '{print $1}'
}

# --- Изпълнение на намиране на storage ---
log_message "Намиране на storage с най-много свободно място..."
BEST_STORAGE=$(get_best_storage)
if [ -z "$BEST_STORAGE" ]; then
    echo -e "\033[1;31mГрешка: Не е намерен наличен storage. Моля, проверете конфигурацията на Proxmox storage-а.\033[0m"
    exit 1
fi
log_message "Избран storage: \033[1;32m$BEST_STORAGE\033[0m"

# --- Проверка и сваляне на шаблона ---
log_message "Проверка за наличие на шаблон $TEMPLATE..."
TEMPLATE_PATH="$BEST_STORAGE:vztmpl/$TEMPLATE"
if ! pveam list $BEST_STORAGE | grep -q "$TEMPLATE"; then
    log_message "Шаблонът $TEMPLATE не е намерен. Сваляне..."
    pveam download $BEST_STORAGE $TEMPLATE
    if [ $? -ne 0 ]; then
        echo -e "\033[1;31mГрешка: Неуспешно сваляне на шаблона $TEMPLATE.\033[0m"
        exit 1
    fi
    log_message "Шаблонът $TEMPLATE е успешно свален."
else
    log_message "Шаблонът $TEMPLATE е наличен."
fi

# --- Генериране на случайна root парола ---
ROOTPASS=$(openssl rand -base64 12)
log_message "Генерирана root парола за контейнера: \033[1;33m$ROOTPASS\033[0m"

# --- Създаване на LXC контейнер ---
log_message "Създаване на LXC контейнер с ID $CTID и име $HOSTNAME..."
pct create $CTID "$TEMPLATE_PATH" \
    -storage "$BEST_STORAGE" \
    -hostname "$HOSTNAME" \
    -memory "$MEMORY" \
    -cores "$CORES" \
    -rootfs "${BEST_STORAGE}:${DISK_SIZE}G" \
    -net0 name=eth0,bridge=vmbr0,ip=dhcp \
    -unprivileged 1 \
    -onboot 1 \
    -password "$ROOTPASS" \
    -features nesting=1

if [ $? -ne 0 ]; then
    echo -e "\033[1;31mГрешка: Неуспешно създаване на LXC контейнер $CTID.\033[0m"
    exit 1
fi
log_message "LXC контейнер $CTID е успешно създаден."

# --- Стартиране на контейнера ---
log_message "Стартиране на контейнера $CTID..."
pct start $CTID
if [ $? -ne 0 ]; then
    echo -e "\033[1;31mГрешка: Неуспешно стартиране на LXC контейнер $CTID.\033[0m"
    exit 1
fi
log_message "Контейнер $CTID е стартиран."

# --- Изчакване контейнерът да получи IP адрес ---
log_message "Изчакване контейнерът $CTID да получи IP адрес. Максимум 30 секунди." 
CONTAINER_IP=""
for i in {1..6}; do
    sleep 5
    CONTAINER_IP=$(pct exec $CTID -- hostname -I | awk '{print $1}')
    if [ -n "$CONTAINER_IP" ]; then
        break
    fi
done

if [ -z "$CONTAINER_IP" ]; then
    echo -e "\033[1;31mГрешка: Контейнерът $CTID не успя да получи IP адрес.\033[0m"
    exit 1
fi
log_message "Контейнерът $CTID получи IP адрес: \033[1;36m$CONTAINER_IP\033[0m"

# --- Инсталиране на UniFi Controller ---
log_message "Стартиране на инсталация на UniFi Network Controller в контейнер $CTID..."

pct exec $CTID -- bash -c "
    log_message_inner() {
        echo \"--- \$(date +'%Y-%m-%d %H:%M:%S') - \$1\"
    }

    set -e

    log_message_inner \"Инсталиране на основни предварителни изисквания...\"
    apt-get update
    apt-get install -y curl gnupg apt-transport-https wget lsb-release ca-certificates ufw

    log_message_inner \"Добавяне на UniFi хранилище и GPG ключ...\"
    if ! wget -qO- https://dl.ui.com/unifi/unifi-repo.gpg | gpg --dearmor > /etc/apt/trusted.gpg.d/unifi-archive-keyring.gpg; then
        log_message_inner \"Грешка: Неуспешно добавяне на UniFi GPG ключ.\"
        exit 1
    fi
    echo 'deb [signed-by=/etc/apt/trusted.gpg.d/unifi-archive-keyring.gpg] https://dl.ui.com/unifi/debian stable ubiquiti' | tee /etc/apt/sources.list.d/100-ubnt-unifi.list >/dev/null

    log_message_inner \"Добавяне на MongoDB хранилище...\"
    DISTRO_ID_INNER=\$(lsb_release -is | tr '[:upper:]' '[:lower:]')
    DISTRO_CODENAME_INNER=\$(lsb_release -cs)
    MONGO_REPO_TYPE_INNER=\"debian\"
    if [ \"\$DISTRO_ID_INNER\" == \"ubuntu\" ]; then
        MONGO_REPO_TYPE_INNER=\"ubuntu\"
    fi
    if ! wget -qO- https://www.mongodb.org/static/pgp/server-$MONGO_VERSION.asc | gpg --dearmor > /etc/apt/trusted.gpg.d/mongodb-archive-keyring.gpg; then
        log_message_inner \"Грешка: Неуспешно добавяне на MongoDB GPG ключ.\"
        exit 1
    fi
    echo \"deb [signed-by=/etc/apt/trusted.gpg.d/mongodb-archive-keyring.gpg] http://repo.mongodb.org/apt/\$MONGO_REPO_TYPE_INNER \$DISTRO_CODENAME_INNER/mongodb-org/$MONGO_VERSION main\" | tee /etc/apt/sources.list.d/mongodb-org-$MONGO_VERSION.list >/dev/null

    log_message_inner \"Актуализиране на списъците с пакети...\"
    for apt_retry_count in {1..5}; do
        apt-get clean
        if apt-get update; then
            break
        else
            sleep 5
        fi
        if [ \$apt_retry_count -eq 5 ]; then
            log_message_inner \"Внимание: apt update се провали след 5 опита.\"
        fi
    done

    log_message_inner \"Инсталиране на OpenJDK 17 JRE...\"
    apt-get install -y openjdk-17-jre-headless

    log_message_inner \"Инсталиране на UniFi Network Controller...\"
    apt-get install -y unifi

    log_message_inner \"Конфигуриране на защитна стена...\"
    ufw allow 8080/tcp
    ufw allow 8443/tcp
    ufw allow 3478/udp
    ufw --force enable

    log_message_inner \"Почистване на системата...\"
    apt-get clean && apt-get autoremove -y && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
"

if [ $? -ne 0 ]; then
    echo -e "\033[1;31mГрешка: Инсталацията на UniFi Controller се провали.\033[0m"
    exit 1
fi
log_message "UniFi Network Controller е инсталиран успешно в контейнер $CTID."

# --- Финален отчет ---
echo -e "\n\033[1;32m✅ UniFi LXC контейнер $CTID е готов!\033[0m"
echo -e "\033[1;35m🎉 Изчакайте няколко минути за пълно стартиране.\033[0m"
echo -e "\033[1;36m🌐 UniFi Controller: https://$CONTAINER_IP:8443\033[0m"
echo -e "\033[1;35m🔑 Root парола: \033[1;33m$ROOTPASS\033[0m"
echo -e "\033[1;33m⚠ Запишете паролата на сигурно място!\033[0m"
echo -e "\033[1;33m⚙ Препоръчваме да създадете стандартен потребител след инсталация.\033[0m"
echo -e "\033[1;35m🔥 Готово! Вашият UniFi контролер вече работи. 🔥\033[0m\n"

exit 0
